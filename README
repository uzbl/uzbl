### THIS PROJECT IS NOT FOR:
* people want a browser that does everything
* people who want a browser with things like a built-in bookmark manager, address bar, forward/back buttons, ...
* people who expect something that works by default.  You'll need to read configs and write/edit scripts


### TO NEW PEOPLE:
* please read the documentation in /usr/share/uzbl/docs
* invoke uzbl --help
* to get you started: uzbl --uri 'http://www.archlinux.org' --config /usr/share/uzbl/examples/configs/sampleconfig
* study the sample config, have a look at all the bindings, and note how you can call the scripts to load new url from history and the bookmarks file
* note that there is no url bar. all url editing is supposed to happen _outside_ of uzbl.
  For now, you can use the `load_from_*` dmenu based scripts to pick a url or type a new one or write commands into the fifo (see /usr/share/uzbl/docs/CHECKLIST)
* If you have questions, you are likely to find answers in the FAQ or in the other documentation.


### INTRODUCTION
  In my opinion, any program can only be really useful if it complies to the unix philosophy.
  Web browsers are frequent violators of this principle:

* They build in way too much things into the browser, dramatically decreasing the options to do things the way you want. 
* They store things in way too fancy formats (xml, rdf, sqlite, ... ) which are hard to store under version control, reuse in other scripts, ...

Time to change that!

  Here are the general ideas:

* each instance of uzbl renders 1 page (eg it's a small wrapper around webkit), no tabbing, tab previews, or speed dial things.
  For "multiple instances management" use your window managers, or scripts. 
  This way you can get something much more useful than tabbing (see rationale in docs)
* very simple, plaintext , changeable at runtime configuration
* various interfaces for (programmatic) interaction with uzbl (see below)
* customizable keyboard shortcuts in vim or emacs style (whatever user wants)
* "outsource" logic that is not browsing to external scripts under the users control:
    - managing bookmarks
    - loading a url from bookmarks, history,..  Editing the curent url
    - control cookies
    - handling of downloads, history logging, etc.
    - management of cache.
    - password management
    - Leverage the power of utilities such as grep, awk, dmenu, zenity, wget, gnupg (password file) etc.
* listen to signals and do useful stuff when triggered.
* no ad blocking built in.
  Alternatives:
    - privoxy looks cool and perfectly demonstrates the unix philosphy.
    - same for http://bfilter.sourceforge.net
    - /etc/hosts (not very good cause you need root and it affects the whole system)
      uzblctrl would need to support an option to list all images on a page, so you can easily pick the links to ads to add them to your /etc/hosts.
* vimperator/konqueror-like hyperlink following.
* password management. maybe an encrypted store that unlocks with an ssh key?
* no messing in the users $HOME or in /etc: no writing of anything unless the user (or sysadmin) asks for it.
  We recommend using XDG basedir spec for separation of config, data and cache. and state should be a subdir in the config dir (not part of the spec yet) too.


### CONFIGURATION / CONTROL:
The general idea is that uzbl by default is very bare bones.  you can send it commands to update settings and perform actions, through various interfaces. (TODO: some default settings)
For examples, please see the sample config(s).
There are several interfaces to interact with uzbl:

* uzbl --config <filename>: <filename> will be read line by line, and the commands in it will be executed.  useful to configure uzbl at startup.
  If you have a file in `$XDG_CONFIG_HOME/uzbl/config` (this expands to ~/.config/uzbl/config on most systems) it will be automatically recognized
* stdin: you can also write commands into stdin
* interactive: you can enter commands (and bind them to shortcuts, even at runtime)
  By default, the behaviour is modal (vi style):
  command mode: every keystroke is interpreted to run commands
  insert mode: keystrokes are not interpreted so you can enter text into html forms
  Press ESC/i to toggle command/insert mode
  But if you don't like modal interfaces, you can set `always_insert_mode` and configure a modkey to execute the commands. (emacs style).
  There is also support for "chained" commands (multiple characters long) (with backspace/esc shortcuts), and keyworded commands.
  Also you can have incremental matching on commands or match after pressing return.  (see sampleconfig for more info)
  Also, copy paste works when typing commands:
  * insert (paste X cliboard)
  * shift insert (paste primary selection buffer)
* FIFO & socket file: if enabled by setting their paths through one of the above means, you can have socket and fifo files available which are very useful to programatically control uzbl (from scripts etc).
  The advantage of the fifo is you can write plaintxt commands to it, but it's half duplex only (uzbl cannot send a response to you).
  The socket is full duplex but you need a socket-compatible wrapper such as netcat to work with it, or uzblctrl of course,
  an utitly we include with uzbl made especially for writing commnands to the socket (and at some point, it will be able to tell you the response
  too):  `uzblctrl -s <socketfile> -c <command>`

### COMMAND SYNTAX
Commands are used for creating binds, altering variables and running actions.  Uzbl will read commands via standard input, named fifo pipe (if fifo_dir is set) and IPC socket (when socket_dir is set).  For convenience, uzbl can also be instructed to read commands from a file on startup by using the `-c' option.  Indeed, the config file is nothing more than a list of commands.

Each command starts with the name of the command, which must be the first thing on a line; preceding whitespace is not allowed.  A command is terminated by a newline.  Empty lines and lines that start with the hash sign are ignored by the parser.  Command names are not case sensitive.

The following commands are recognized:

    SET <key> = <value>
Set is used for changing variables.  Every variable can be changed on the fly and the changes are processed immediately; for example, setting the variable 'uri' will make uzbl start loading it.  If you want to unset a string, use SET with one space after the equals sign.

    GET <key>
Use this to print the value of a key.

    BIND <string> = <action>
Makes the character sequence <string> invoke <action> when typed interactively in uzbl.  If <string> ends with an underscore, the action will be invoked when return or enter is pressed, and the input starting from the position of the underscore will be expanded in place of '%s' in the <action> string.  The <action> does not need to have '%s' in it when you use the underscore, in which case no expansion takes place, but you're uzbl will still wait for you to press return before invoking the action.  You can also use an asterisk, which behaves much like underscore, but also makes the binding incremental (i.e. the action will be invoked on every keystroke).  Examples follow:
    bind o _ = uri %s
    bind /*  = search %s
    bind ZZ  = exit
Using the first example, uzbl will load the url you entered by typing an 'o', a space, the url you want to see and by finishing with a stroke of return or enter.  In the second example is a search action which is called on every character you type after the slash, letting you see the search narrow down on the words as you type it.  Hitting return, enter or esc will terminate the search.  The last example is a plain binding which will run immediately as soon as it's written; there's no waiting for return.

    ACT <action>
This tells uzbl to execute an action immediately.  The simplest example of this would be "act exit"; you know what that'll do.

    KEYCMD <string>
This sets the interactive command buffer to <string>.  Keycmd is primarily useful for scripts that help you type a command while still letting you edit it before execution.  For example, if you have a binding like "o _" that opens an URL, then you could create a binding O that spawns a script which will set the command buffer to "o <current-uri-here>", letting you enter relative URLs easily.


### VARIABLE REPLACEMENT
Some of the variables are interpreted:

* title bar: variable replacement (long and short version, depending if statusbar is visible or not)
* user agent: variable replacement
* statusbar: variable replacement + pango markup

This means you can customize how these things appear, what's shown in them and for the statusbar you can even play with the layout.
For examples, see the example config.
For a list of possible variables, see uzbl.h
For more info about the markup format see http://library.gnome.org/devel/pango/stable/PangoMarkupFormat.html


### EXTERNAL SCRIPTS
You can use external scripts with uzbl the following ways:

* let uzbl call them. these scripts are called handlers in the uzbl config. used for handling logging history, handling a new download,.. 
* call them yourself from inside uzbl.  you can bind keys for this. examples: add new bookmark, load new url,..
* You could also use xbindkeys or your WM config to trigger scripts if uzbl does not have focus

Have a look at the sample configs and scripts!

Scripts that are called by uzbl are passed the following arguments:

    $1 uzbl-config-file
    $2 uzbl-pid
    $3 uzbl-x-window-id
    $4 uzbl_fifo-filename
    $5 uzbl_socket-filename
    $6 current page url
    $7 current page title
    .. [ script specific ] (optional)

The script specific arguments are this:

* history:

    $8 date of visit (Y-m-d H:i:s localtime)

* add bookmark:

    none

* download:

    $8 url of item to download

* cookie handler

    $8 GET/PUT
    $9 request address host (if current page url is www.foo.com/somepage, this could be something else then foo, eg advertising from another host)
    $10 request address path
    $11 cookie (only with PUT requests)


### COMMAND LINE ARGUMENTS

    -u, --uri=URI            Uri to load (equivalent to 'set uri = URI')
    -v, --verbose=VERBOSE    Whether to print all messages or just errors.
    -n, --name=NAME          Name of the current instance (defaults to Xorg window id)
    -c, --config=FILE        Config file (this is pretty much equivalent to uzbl < FILE )
    --display=DISPLAY        X display to use
    --help                   Help


### BUGS
known bugs:

* Segfaults when using zoom commands (happens when max zoom already reached?).

Please report new issues @ uzbl.org/bugs


